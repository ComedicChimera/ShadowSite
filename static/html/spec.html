<h1>The Whirlwind Language Specification</h1>
<h2>Table of Contents</h2>
<ol>
<li>
<p><a href="#intro">Introduction</a></p>
<ul>
<li><a href="#1-purpose">Purpose</a></li>
<li><a href="#1-copy">Copyright</a></li>
<li><a href="#1-notation">Notation</a></li>
</ul>
</li>
<li>
<p><a href="#lexical-structure">Lexical Structure</a></p>
<ul>
<li><a href="#2-comments">Comments</a></li>
<li><a href="#2-punctuation">Punctuation</a></li>
<li><a href="#2-identifiers">Identifiers</a></li>
<li><a href="#2-keywords">Keywords</a></li>
<li><a href="#2-operators">Operators</a></li>
<li><a href="#2-literals">Literals</a></li>
</ul>
</li>
<li>
<p><a href="#prim-types">Primitive Types</a></p>
<ul>
<li>Byte Types</li>
<li>Character Types</li>
<li>Integral Types</li>
<li>Floating-Point Types</li>
<li>Boolean Types</li>
<li>String Types</li>
<li>Any Types</li>
<li>None Types</li>
</ul>
</li>
<li>
<p><a href="#collections">Collections</a></p>
<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#dicts">Dictionaries</a></li>
<li><a href="#tuples">Tuples</a></li>
</ul>
</li>
<li>
<p><a href="#expressions">Expressions</a></p>
<ul>
<li>Nesting</li>
<li>Precedence</li>
<li>Atoms</li>
<li>Unary Expressions</li>
<li>Arithmetic Expressions</li>
<li>Shift Expressions</li>
<li>Comparison Expressions</li>
<li>Logical Expressions</li>
<li>Functional Expressions</li>
<li>Expression Local Variables</li>
<li>Ternary Expressions</li>
<li>Case Expressions</li>
<li>Range Expressions</li>
<li>Then Expressions</li>
<li>Is Expressions</li>
<li>Cast Expressions</li>
<li>Extract Expressions</li>
<li>Constant Expressions</li>
</ul>
</li>
<li>
<p>Statements</p>
<ul>
<li>Variable Declarations</li>
<li>Constancy and Constexpr</li>
<li>Assignment</li>
<li>Simple Statements</li>
<li>If Statements</li>
<li>Select Statements</li>
<li>For Loops</li>
<li>Context Managers</li>
<li>After Clauses</li>
</ul>
</li>
<li>
<p>Functions</p>
<ul>
<li>Function Declarations</li>
<li>Function Groups</li>
<li>First Class Functions</li>
<li>Lambdas and Closures</li>
<li>Composition</li>
<li>Partial Functions</li>
<li>Monads</li>
</ul>
</li>
<li>
<p>User-Defined Types</p>
<ul>
<li>Structure Types</li>
<li>Interface Types</li>
<li>Opaque Types</li>
<li>Type Aliases</li>
<li>Enumerated Types</li>
<li>Algebraic Types</li>
</ul>
</li>
<li>
<p>Interface Binding</p>
<ul>
<li>Methods</li>
<li>Classification</li>
<li>Default Implementation</li>
<li>Overriding</li>
<li>Operator Overloading</li>
<li>Special Methods</li>
</ul>
</li>
<li>
<p>Generics</p>
<ul>
<li>Generic Types</li>
<li>Generic Restrictors</li>
<li>Generate Construction</li>
<li>Monomorphism</li>
<li>Variance</li>
</ul>
</li>
<li>
<p>Symbols and Scoping</p>
<ul>
<li>Declaration Order</li>
<li>Compound Definitions</li>
<li>Incomplete Definitions</li>
<li>Scoping</li>
<li>Shadowing</li>
<li>Captures</li>
</ul>
</li>
<li>
<p>Memory Model</p>
<ul>
<li>Pointer Types</li>
<li>Heap Allocation</li>
<li>Heap Deallocation</li>
<li>Moving and Copying</li>
<li>Nullable Operators</li>
<li>Implicit Deallocation</li>
<li>Ownership</li>
<li>Lifetimes</li>
</ul>
</li>
<li>
<p>Concurrency</p>
<ul>
<li>Fibers</li>
<li>Futures</li>
<li>Asynchronous Functions</li>
<li>Await and Shields</li>
<li>Volatility</li>
<li>Race Conditions</li>
</ul>
</li>
<li>
<p>Packages</p>
<ul>
<li>Package Assembly</li>
<li>Export Status</li>
<li>Inclusion</li>
<li>Data Organization</li>
</ul>
</li>
<li>
<p>Annotations</p>
<ul>
<li>File-Level Annotations</li>
<li>Block Annotations</li>
<li>Annotation Interpretation</li>
</ul>
</li>
<li>
<p>Runtime and Execution</p>
<ul>
<li>The Main Function</li>
<li>Stack Allocation</li>
<li>Forced Copying</li>
<li>Error Model</li>
<li>Stack Tracing</li>
<li>Dynamic Allocation</li>
<li>Concurrency</li>
<li>Compile-Time Intrinsics</li>
</ul>
</li>
</ol>
<h2><a name="intro"></a> Introduction</h2>
<p>This specification is a complete reference manual and description
of the Whirlwind Programming Language.  It describes the exact behavior
and construction of each language element as well as the relation between
language elements.</p>
<h3><a name="1-purpose"></a> Purpose</h3>
<p>Whirlwind is a compiled, modern, and multipurpose language designed with intentionality.
It is strongly-typed, versatile, expressive, concurrent, and relatively easy to learn.  It does not
have a garbage collector and accordingly places a heavy emphasis on memory safety.
It boasts numerous new and old features and is designed to represent the needs of any software developer.</p>
<h3><a name="1-copy"></a> Copyright</h3>
<p>Whirlwind is by nature a piece of intellectual property.  That being said, it is
powered by and thrives off of its community and as such it has some rather unique
rules for usage.</p>
<h3><a name="1-notation"></a> Notation</h3>
<p>Our grammatical notation uses a modified form of EBNF (Extended Backus-Naur Form) that allows for comments and does not include a <code>?</code> operator
or token literals.  Additionally, it uses a different production declaration operator.</p>
<p>The below code block outlines the syntactic notation used in our custom EBNF notation.</p>
<pre><code class="language-javascript">// This is a comment

/* This is a multiline comment */

// Tokens (Terminals) are encased in single quotes, and all productions are ended by semicolons.
production_name: 'TOKEN' ;

// Our format allows for alternators and parentheses
alternated_production: ( production | 'TOKEN' ) | production ;

// and optional blocks
optional_production: [ production ] ;

// star and plus operators
operator_production: production* production+ ;
</code></pre>
<p>This simple notation is all that used to define the Whirlwind grammar and will be used in this specification.  </p>
<p>Additionally, regular expressions are infrequently used throughout this specification and will be marked with
forward slashes on either side when used.</p>
<h2><a name="lexical-structure"></a> Lexical Structure</h2>
<p>This section will describe the basic lexical structure as well as some of the simpler code fragments (eg. literals)
in the Whirlwind programming language.</p>
<h3><a name="2-comments"></a> Comments</h3>
<p>A comment represents any piece of code that will not be processed by the compiler.  Comments take two forms in
Whirlwind: single-line and multi-line.  They take the following form:</p>
<pre><code class="language-whirlwind">// single-line comment

/* multi-line comment */
</code></pre>
<p>As the name would imply, the former type of comment occupies one line, and the latter type of comment can be spread over multiple lines.<br />
Additionally, multi-line comments must always be bounded on both sides the appropriate symbols (<code>/*</code> for the left, <code>*/</code> for the right).</p>
<pre><code class="language-whirlwind">/* multi-
line
comment */
</code></pre>
<p>Finally, it is also legal (although not advised) to embed single-line comments within multi-line comments</p>
<pre><code class="language-whirlwind">/*
// nested comment
*/
</code></pre>
<p>Because the content of all comments is completely ignored, it is of no consequence to the compiler what you place inside the comment,
excluding the symbols used to end multi-line comments which will cause the compiler to think the comment has ended.</p>
<h3><a name="2-punctuation"></a> Punctuation</h3>
<p>Whirlwind requires that several different pieces of punctuation be used in different scenarios.  The most notable of which is the
semicolon which primarily denotes the end of block-less <a href="#statements">statement</a>.  Another notable piece of punctuation is the colon which
primarily denotes a type label (or type extension; both names are acceptable) all of which take the form <code>: type</code> where type is replaced
with the desired type for the label.</p>
<p>Another important piece of punctuation is the brace: its two forms (left and right) are used to begin and end a code block.</p>
<pre><code class="language-whirlwind">{
    // code here
}
</code></pre>
<p>There are several other pieces of punctuation used in Whirlwind, and they are, including those already mentioned, listed here.</p>
<pre><code class="language-whirlwind">;   ,   (   )   {   }   
.   =&gt;  #   @   ... :
</code></pre>
<p>Many of the aforementioned punctuation elements have multiple uses and meanings and do not always denote punctuation.</p>
<h3><a name="2-identifiers"></a> Identifiers</h3>
<p>In Whirlwind, an <code>identifier</code> is anything that represents a symbol.  That is to say, it is a name.  In Whirlwind, all identifiers must follow
the following regular expression:</p>
<pre><code class="language-javascript">/[^\d\W]\w*/
</code></pre>
<p>This regular expression indicates that an identifier begins with some letter upper or lowercase and is followed by any number of letters, numbers
or underscores. Additionally, it is important to note that identifiers must be bounded on either side by any character that is not a letter, number or underscore.</p>
<p>Note that Whirlwind does not allow dollar signs in variable names and that a single underscore is <strong>not</strong> a variable name and is used for other purposes in the
language.  However, variables may be prefixed with any number of underscores although prefixing with more than one underscore is not recommended as it could cause
conflicts with compiler or prelude declared symbols.</p>
<h3><a name="2-keywords"></a> Keywords</h3>
<p>A keyword is any word, which in this context is a combination of lowercase letters, that is reserved by the compiler for any special purpose.  Below is a list
of all keywords used in Whirlwind.</p>
<pre><code class="language-whirlwind">let        const      if         elif       else       for
select     case       default    break      continue   when
after      return     yield      delete     from       make
with       func       async      await      variant    constructor
operator   type       struct     interf     include    export
this       super      new        null       is         then
value      as         vol        static     own        dyn
</code></pre>
<p>It is important to note that the last four items in this list above are most accurately referred to as modifiers not keywords, but they follow the same semantics
as all other keywords do.</p>
<p>Finally, it is acceptable (although in many cases not adviseable) to use keywords within identifiers: a keyword may be part of a larger identifier.
For example, the following identifiers would be considered valid:</p>
<pre><code class="language-whirlwind">typeX
my_static_var
new13
my_value
forThis
orelse
include6
withAll
</code></pre>
<p>However, if the identifier is malformed then the keyword will still match separately.  Furthermore, keywords are case-sensitive so an identifier comprised
of a differently-cased form of one of the keywords would be acceptable as well.</p>
<h3><a name="2-operators"></a> Operators</h3>
<p>An operator is any symbol that denotes an operation.  Whirlwind contains many different kinds operators, varying both in the number of operands they accept and
the symbols (or keyword) used to represent them.  For the sake of efficiency, below is a list of all of the standard operators.</p>
<pre><code class="language-whirlwind">&gt;&gt;=   :&gt;   :=   ++   --   -&gt;   &lt;    ~    *    ?
!=    !    &amp;&amp;   ||   ^^   |    &lt;-   &gt;    ~/   ~^ 
/     %    ==   &gt;=   &lt;=   =    &amp;    ~*   +    -
</code></pre>
<p>Notably, some of the operators listed can be combined with the <code>=</code> operator to form a <a href="#6-assignment">compound assignment</a> operator.  </p>
<p>Finally, they are several operators that were not listed in the above list because they are either primarily considered some other type of lexical element.
Furthermore, all of these operators are considered non-standard operators due to the operands they accept and/or the function they perform.  Many of these
non-standard operators also do not accept operands in the traditional unary or binary manner that all of the standard operators listed above.</p>
<h3><a name="2-literals"></a> Literals</h3>
<p>A literal represents a single, discreet value used in code.  For example, the number <code>3</code> could be considered a literal because it is single, constant
value.  There are 7 different types of literals in Whirlwind and each is associated with a specific <a href="#prim-types">primitive type</a>.</p>
<h4>Integral Literals</h4>
<p>An integral literal represents a non-negative whole number that corresponds to one of the <a href="#3-int-types">integral types</a> and a specific signage.
All integral literals will take the following form.</p>
<pre><code class="language-javascript">/\d+[ul]*/
</code></pre>
<p>Notice that these literals can end with a suffix denoted which specific integral type they correspond to.  The suffix <code>u</code> marks the integral
literal as unsigned and the <code>l</code> suffix marks it as a long type.  By default, integral literals default to signed integers.</p>
<p>If the value held by the integral value is outside the range of allowed values for a signed integer literal, it will be interpreted as the smallest
integral type starting from the signed integer type that can hold its value.  Moreover, since the suffixes only increase the maximum range, they can
never contradict with this upcasting pattern; rather, they merely provide a base size to cast up from if necessary.  </p>
<p>Finally, if the value is too large to be stored in the largest possible integral type, then the program will fail to compile.</p>
<h4>Floating-Point Literals</h4>
<p>A floating-point literal represents a decimal number that corresponds to one of the <a href="#3-float-types">floating-point types</a>.  All floating-point literals
will take the following form.</p>
<pre><code class="language-javascript">/\d+\.\d+d?/
</code></pre>
<p>Akin to integer literals, floating-point types can also end with a suffix <code>d</code> that denotes it as a <code>double</code> instead of a <code>float</code>.  Additionally,
if the value it stores has a greater precision than the base float type allows or has a greater value that the float type allows, the literal
will automatically be upcast to a double type.  If this upcast is still insufficient, the program will fail to compile.</p>
<h4>Character Literals</h4>
<p>A character literal represents a single UTF-8 encoded, unicode point that corresponds to the <a href="#3-char-types">character type</a>.  This literal is
enclosed in single quotes and must contain exactly one value.</p>
<pre><code class="language-javascript">/'(?:[^\"\\']|\\.)'/
</code></pre>
<p>The character literal can contain any unicode character or one of the following legal escape codes (each followed by its function in parentheses):</p>
<pre><code>\a (alert)
\b (backspace)
\f (form feed)
\n (new line)
\r (carriage return)
\t (horizontal tab)
\v (vertical tab)
\0 (null terminator)
\s (space)
\" (escaped double quote)
\' (escaped single quote)
\\ (escaped backslash)
</code></pre>
<p>In addition, the prefix <code>\u</code> may be used to signal partial unicode character code (16 bits) and the prefix <code>\U</code> may be used to signal a full unicode
character code (32 bits) where the appropriate number of hexadecimal characters follows the the escape prefix.</p>
<h4>Boolean Literals</h4>
<p>A boolean literals represents a single boolean (true/false) value that corresponds to the <a href="#3-bool-types">boolean type</a>.  This literal can hold
two values: <code>true</code> and <code>false</code> as expressed below:</p>
<pre><code class="language-javascript">/\b(true|false)\b/
</code></pre>
<p>In this literal, <code>true</code> corresponds to the boolean value true (1) and <code>false</code> corresponds to the boolean value false (0).  </p>
<h4>String Literals</h4>
<p>A string literal represents a string of unicode characters that corresponds to the <a href="#3-string-types">string type</a>.  This literal
matches the regular expression below.</p>
<pre><code class="language-javascript">/\"(?:[^\"\\']|\\.)*\"/
</code></pre>
<p>This literal may contain any escape code or unicode character code that would be valid as a character literal.  Moreover, these literals
may contain as many or as few characters as necessary.  </p>
<p>String literals (and strings by extension) may also contain no values.  These strings are termed as empty strings and have a length of 0.
Notably, these strings do still occupy memory and can be manipulated as if they were a proper string.  However, any attempt to read a value
from this string (though a subscript) will result in a runtime error.</p>
<h4>Binary and Hexadecimal Literals</h4>
<p>Binary and hexadecimal literals represent an arbitrary piece of data.  All binary and hexadecimal literals correspond to either a <a href="#3-byte-types">byte type</a>
or an <a href="#3-integral-types">integral type</a> depending exclusively on the type of data they hold.  Furthermore, the correspondent type is always
unsigned.</p>
<p>Binary literals take the following form:</p>
<pre><code class="language-javascript">/0b[10]{1,64}/
</code></pre>
<p>Notice that these literals are prefixed by <code>0b</code> and may only contain up to 64 characters (corresponding to the <code>ulong</code> type) and must contain at least
one character.  </p>
<p>As noted previously, the size of the resulting type is determined by the size of the literal.  In this case, the number of bits in the literal
corresponds directly with the type is will evaluate to.  That is to say, a binary literal will be inferred as the smallest type that occupies
a greater or equal number of bits than the number contained within the binary literal.</p>
<p>Hexadecimal literals take the following form:</p>
<pre><code class="language-javascript">/0x[0-9A-F]{1,16}/
</code></pre>
<p>All hexadecimal literals are prefixed by <code>0x</code> and must contain at least one character but no more than 16 characters (corresponding to the <code>ulong</code> type).
Furthermore, only capital letters may be used as hexadecimal digits within a hexadecimal literal.  </p>
<p>Hexadecimal literals follow a similar type progression to binary literals; however, the space that the hexadecimal literal occupies is determined
by the space required to store the binary value of the hexadecimal literal.  By contrast, with respect to the determined size of the literal,
the type determination process is identical to that of a binary literal.</p>
<p>Finally, in both literals, 0s still count as a additional space in the literal.  That is to say, the size of the inferred type is determined not by the
actual used memory of literal but rather by the number of characters specified in the literal.  For example, <code>0x000</code> will evaluate to a larger type than <code>0x00</code>.</p>